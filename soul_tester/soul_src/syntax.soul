import Std::Mem::[RawArray, Global, Allocable]

class List<T, Mem = Global> 
where 
    Mem: Allocable
{
    literal EMPTY_LEN = 0
    mut array: ?*T = null
    mut len Get = uint(0)
    mut cap Get = uint(0)

    This(cap: uint) {
        return This{array: Mem.MallocArray(cap), len: 0, cap}
    }

    This:[vec: []T] {
        len := vec.Len()
        cap := vec.Cap()
        return This{array: vec.To(), len, cap}
    }

    Push(&this, el: T) {
        mut array = this.array ?? return
        if len+1 > cap {
            reserve(cap*2)
        }

        unsafe{
            array.index(len++) = el
        }
    }

    Pop(&this): ?T {
        if len == 0 {
            return null
        } 

        unsafe {
            return array?.index(len--)
        }
    }

    ExpectPop(&this): Res<T, str> {
        val := Pop() ?? return Err("List is empty")
        return Ok(val)
    }

    reserve(&this, cap: uint) {
        Mem.Realloc(array, cap)
    }
}

Test test_list() {
    
    emptyList := List()
    AssertEq!(emptyList.len, 0)
    AssertEq!(emptyList.cap, 0)

    vec := [1, 2, 3]
    filledList := List:[int: 1, 2, 3]
    AssertEq!(emptyList.len, 3)
    AssertEq!(emptyList.cap, vec.Cap())

    mut list = List(10)
    AssertEq!(emptyList.len, 0)
    AssertEq!(emptyList.cap, 10)

    literal NOT_FOUND = 404

    list.Push(1)
    mut element: int = list.Pop() ?? NOT_FOUND

    element = list.ExpectPop() 
        .catch err => {
            Println(err)
            NOT_FOUND 
        }

    passError(list: List<int>): Res<none, str> {
        element := list.ExpectPop().pass
    }

    element = list.ExpectPop().try

    len := list.len
}
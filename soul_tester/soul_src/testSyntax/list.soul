class List<T, Mem = Malloc> 
where
    Mem: Allocator
{
    literal INCREASE_FACTOR: f64 = 2.0
    mut buffer: [*]?T = []
    mut len: uint = 0

    This(capacity: uint = 0) {
        TryNew(capacity).catch{Panic}
    }

    This:[T](array) {
        TryFromArray(array).catch{Panic}        
    }

    TryFromArray(array: [_]T): Err<This> {
        mut self = TryNew(array.Len()).pass
        self.ExtendArray(array).pass
        return self
    }

    TryNew(capacity: uint): Err<This> {
        mut self = This{..}
        self.Reserve(capacity).pass
        return self
    }

    Len(@this): uint {
        return len
    }

    Cap(@this): uint {
        return buffer.Len()
    }

    ExtendArray(&this, array: [_]T): Err {
        ReserveAtLeast(array.Len()).pass
        for value in array {
            Push(value)
        }
    }

    Push(&this, value: T) {
        TryPush(value).catch{Panic}
    }

    TryPush(&this, value: T): Err {
        if len+1 > Cap() {
            grow().pass
        }

        buffer[len++].pass = value
    }

    Pop(&this): ?T {
        TryPop().catch{Panic}
    }

    TryPop(&this): Err<?T> {
        if len == 0 {
            return null
        }

        mut temp = null
        Swap(&buffer[--len].pass, &temp)

        return temp ?? error.@str("Pop element is somehow Uninit")
    }

    Reserve(&this, toCapacity: uint): Err {
        import std::mem::Swap

        old := buffer
        buffer = new<Mem>:[for toCapacity => null].pass

        minLen := len.min(toCapacity)
        for i in 0..minLen {
            Swap(&buffer[i].pass, &old[i].pass)
        }

        buffer = tempPtr
    }

    Resize(&this, toCapacity: uint, default: T): Err {
        import std::mem::Swap

        old := buffer
        buffer = new<Mem>:[for toCapacity => default.copy].pass

        minLen := len.min(toCapacity)
        for i in 0..minLen {
            Swap(&buffer[i].pass, &old[i].pass)
        }

        buffer = tempPtr
    }

    ReserveAtLeast(len: uint): Err {
        mut capReserve := f64(Cap().Min(1))
        capNeeded := f64(len + Len())
        while capReserve < capNeeded {
            capReserve = capReserve * INCREASE_FACTOR
        }

        return Reserve(uint(capReserve))
    }

    grow(): Err {
        oldCap := f64(Cap().Min(1))
        cap := uint(oldCap * INCREASE_FACTOR)
        return Reserve(cap)
    }

    impl OpuaqeIndex<T> {
        index(mut this, index: uint): Err<&T, OutOfBounds> {
            use core::err::OutOfBounds;
            
            if index < len {
                return error.OutOfBounds(len, index)
            }

            return &buffer[index]
        }
    }
}
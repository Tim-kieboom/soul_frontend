import Std::Sync::Atomic::[AtomicBool, Ordering]

enum LockError {
    PoisonError, 
    NoAquireError,
}

use LockResult<'a, T> = Res<Guard<'a, T>, LockError.PoisonError>
use TryLockResult<'a, T> = Res<Guard<'a, T>, LockError>

class Mutex<T> {
    isLocked: AtomicBool
    data: UnsafeMutable<T>

    This(value: T) {
        return This {
            isLocked: AtomicBool(false),
            data: UnsafeMutable(value),
        }
    }

    Lock(@this): LockResult<'_, T> {
        
        while isLocked.swap(true, Ordering::Acquire) {
            Std::Hint::cpuYield()
        }

        return Ok(
            Guard(this)
        )
    }

    TryLock(@this): TryLockResult<'_, T> {
               
        if isLocked.swap(true, Ordering::Acquire) {
            return Err(
                LockError.NoAquireError
            )
        }
        
        return Ok(
            Guard(this)
        )
    }

    impl Send{}
    impl Sync{}
}

class Guard<'a, T> {
    mutex: @'a Mutex<T>,

    impl ConstRef<T> {
        ConstRef(@this) -> @T {
            return unsafe {
                mutex.data.GetRef()
            }
        }
    }

    impl MutRef<T> {
        MutRef(&this) -> &T {
            return unsafe {
                mutex.data.GetMutRef()
            }
        }
    }

    impl Drop {
        Drop(&this) {
            mutex.isLocked.store(false, Ordering::Release)
        }
    }
}

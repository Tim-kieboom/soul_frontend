import Std::Sync::Atomic::[AtomicBool, Ordering]

union LockError {
    PoisonError,
    NoAquireError,
}

use LockResult<'a, T> = Res<MutexGuard<'a, T>, LockError.PoisonError>
use TryLockResult<'a, T> = Res<MutexGuard<'a, T>, LockError>

class Mutex<T> {
    isLocked: AtomicBool
    data: UnsafeMutable<T>

    This(value: T) {
        return This {
            isLocked: AtomicBool(false),
            data: UnsafeMutable(value),
        }
    }

    Lock(@this): LockResult<'_, T> {
        
        while this.isLocked.swap(true, Ordering::Acquire) {
            Std::Hint::cpuYield()
        }

        return Ok(
            MutexGuard(this)
        )
    }

    TryLock(@this): TryLockResult<'_, T> {
               
        if this.isLocked.swap(true, Ordering::Acquire) {
            return Err(
                LockError.NoAquireError
            )
        }
        
        return Ok(
            MutexGuard(this)
        )
    }

    impl Send{}
    impl Sync{}
}

class PoisonFlag {
    atomicCheck: AtomicBool
}

class MutexGuard<'a, T> {
    mutex: @'a Mutex<T>,

    impl ConstRef<T> {
        ConstRef(@this) -> @T {
            return unsafe {
                this.mutex.data.GetValueConst()
            }
        }
    }

    impl MutRef<T> {
        MutRef(&this) -> &T {
            return unsafe {
                this.mutex.data.GetValueMut()
            }
        }
    }

    impl Drop {
        Drop(&this) {
            this.mutex.isLocked.store(false, Ordering::Release)
        }
    }
}

import Std::Mem::[RawArray, Global, Allocable]

class List<T, Alloc = Global> 
where 
    Alloc: Allocable
{
    literal EMPTY_LEN = 0
    mut array = RawArray:[]
    mut len Get = uint(0)
    mut cap Get = uint(0)

    This(cap: uint) {
        return This{array: RawArray(cap), len: 0, cap}
    }

    This:[vec: []T] {
        len := vec.Len()
        cap := vec.Cap()
        return This{array: vec.To(), len, cap}
    }

    Push(&this, el: T) {
        if this.len+1 > this.cap {
            this.reserve(this.cap*2)
        }

        this.array[this.len++] = el
    }

    Pop(&this): ?T {
        if this.len == 0 {
            return null
        } 

        return this.array[this.len--]
    }

    ExpectPop(&this): Res<T, str> {
        if this.len == 0 {
            return Err("List is empty")
        }
        
        return Ok(this.array[this.len--])
    }

    reserve(&this, cap: uint) {
        this.array.realloc(cap)
    }
}

Test test_list() {
    
    emptyList := List()
    AssertEq!(emptyList.len, 0)
    AssertEq!(emptyList.cap, 0)

    vec := [1, 2, 3]
    filledList := List:[1, 2, 3]
    AssertEq!(emptyList.len, 3)
    AssertEq!(emptyList.cap, vec.Cap())

    mut list = List(10)
    AssertEq!(emptyList.len, 0)
    AssertEq!(emptyList.cap, 10)

    literal NOT_FOUND = 404

    list.Push(1)
    mut element: int = list.Pop() ?? NOT_FOUND

    element = list.ExpectPop() 
        .catch err => {
            Println(err)
            NOT_FOUND 
        }

    passError(list: List<int>): Res<none, str> {
        element := list.ExpectPop().pass
    }

    element = list.ExpectPop().try

    len := list.len
}
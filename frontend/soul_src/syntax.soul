use std::mem::[RawArray, Global, Allocable]

class List<T, Alloc = Global> 
where 
    Alloc: Allocable
{
    array: RawArray<T> = []
    len: uint Get = 0  
    cap: uint Get = 0

    This(cap: uint) {
        return This{array: RawArray(cap), len: 0, cap}
    }

    This[vec: []T] {
        len := vec.Len()
        cap := vec.Cap()
        return This{array: vec.To(), len, cap}
    }

    Push(&this, el: T) {
        
        if this.len+1 > this.cap {
            this.reserve(this.cap*2)
        }

        this.array[this.len++] = el
    }

    Pop(&this): ?T {
        this.len == 0 ? None : Some(this.array[this.len--])
    }

    ExpectPop(&this): Res<T, str> {
        this.len == 0 ? Err("List is empty") : Ok(this.array[this.len--])
    }

    reserve(&this, cap: uint) {
        this.array.realloc(cap)
    }
}

Test test_list() {
    
    emptyList := List()
    AssertEq!(emptyList.len, 0)
    AssertEq!(emptyList.cap, 0)

    vec := [1, 2, 3]
    filledList := List[1, 2, 3]
    AssertEq!(emptyList.len, 3)
    AssertEq!(emptyList.cap, vec.Cap())

    mut list = List(10)
    AssertEq!(emptyList.len, 0)
    AssertEq!(emptyList.cap, 10)

    literal NOT_FOUND = 404

    list.Push(1)
    mut element: int = list.Pop() ?? NOT_FOUND

    element = list.ExpectPop() 
        .catch err => {
            Println(err)
            NOT_FOUND 
        }

    passError(list: List<int>): Res<none, str> {
        element := list.ExpectPop().pass
    }

    element = list.ExpectPop().try

    len := list.len
}